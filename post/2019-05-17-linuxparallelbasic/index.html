<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>小议 linux 并行方法 - 思考问题的熊</title>
<link rel="shortcut icon" href="https://kaopubear.top//favicon.ico">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.2.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css">
<link rel="stylesheet" href="https://kaopubear.top//media/css/tailwind.css">
<link rel="stylesheet" href="https://kaopubear.top//styles/main.css">
<link rel="alternate" type="application/atom+xml" title="小议 linux 并行方法 - 思考问题的熊 - Atom Feed" href="https://kaopubear.top//atom.xml">


  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-91022805-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
  
    gtag('config', 'UA-91022805-1');
  </script>
    

  <meta name="description" content="─=≡Σ(((つ •̀ω•́) つ 车速飚起来，坐稳扶好


前几天朋友圈各种神仙「打架」秀了一波在 R 里分组统计的骚操作，思路总结起来大致是：split-apply-combine。果子还给我直接来了一次需求提速，几个月前需要十几分钟完..." />
  <meta property="og:title" content="小议 linux 并行方法 - 思考问题的熊">
  <meta property="og:description" content="─=≡Σ(((つ •̀ω•́) つ 车速飚起来，坐稳扶好


前几天朋友圈各种神仙「打架」秀了一波在 R 里分组统计的骚操作，思路总结起来大致是：split-apply-combine。果子还给我直接来了一次需求提速，几个月前需要十几分钟完..." />
  <meta property="og:type" content="articles">
  <meta property="og:url" content="https://kaopubear.top/post/2019-05-17-linuxparallelbasic" />
  <meta property="og:image" content="https://raw.githubusercontent.com/fei0810/image-host/master/img/20190605235551.png">
  <meta property="og:image:height" content="630">
  <meta property="og:image:width" content="1200">
  <meta name="twitter:title" content="小议 linux 并行方法 - 思考问题的熊">
  <meta name="twitter:description" content="─=≡Σ(((つ •̀ω•́) つ 车速飚起来，坐稳扶好


前几天朋友圈各种神仙「打架」秀了一波在 R 里分组统计的骚操作，思路总结起来大致是：split-apply-combine。果子还给我直接来了一次需求提速，几个月前需要十几分钟完...">
  <meta name="twitter:card" content="summary_large_image">
  <link rel="canonical" href="https://kaopubear.top/post/2019-05-17-linuxparallelbasic">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
 
  
    <link rel="stylesheet" href="https://kaopubear.top//media/css/prism-atom-dark.css">
  

  
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
  
</head>

<body>
  <div class="antialiased flex flex-col min-h-screen" id="app">
    <a href="https://kaopubear.top/" class="fixed top-0 left-0 mt-4 bg-black text-white dark:text-gray-700 dark:bg-yellow-50 dark:hover:bg-black dark:hover:text-white inline-flex p-2 pl-8 hover:text-gray-700 hover:bg-yellow-50 font-bold z-10 transition-fast animated fadeInLeft">
      思考问题的熊
    </a>
    <div class="max-w-4xl w-full mx-auto">
      <div class="shadow-box bg-white dark:bg-gray-600 rounded-lg pt-32 md:pt-64 px-4 md:px-8 pb-8 animated fadeIn mb-8">
        <h1 class="text-5xl font-semibold leading-normal pb-8 mb-8 border-b-8 border-gray-700">
          小议 linux 并行方法
        </h1>
        
          <img src="https://raw.githubusercontent.com/fei0810/image-host/master/img/20190605235551.png" alt="小议 linux 并行方法" class="block w-full mb-8">
        
        <div class="mb-8 flex flex-wrap">
          <div class="text-gray-400 text-sm mr-4">2019-05-17 · 13 min read</div>
          
            <a href="https://kaopubear.top/tag/v0Xcy0jQaT" class="text-gray-700 text-sm border-b-2 border-dotted border-gray-200 hover:border-gray-600 transition-all duration-100 inline-flex mr-2">
              <i class="ri-hashtag"></i>
              linux
            </a>
          
        </div>
        <div class="markdown mb-8" v-pre>
          <p>─=≡Σ(((つ •̀ω•́) つ 车速飚起来，坐稳扶好</p>
<!-- more -->
<blockquote>
<p>前几天朋友圈各种神仙「打架」秀了一波在 R 里分组统计的骚操作，思路总结起来大致是：split-apply-combine。果子还给我直接来了一次需求提速，几个月前需要十几分钟完成的操作如今只要十几秒就拿下了，特别生猛。</p>
</blockquote>
<p>在 linux 环境下，不少软件和命令其实也都面临着如何提速的问题。我现在还记得大概一年前 jimmy 问过一个问题：要从一个很大的文本中提取出一批想要的行，如果用 <code>grep -f hewantfile.txt rawdata.txt</code> 来 grep 的话实在是太慢了。当然，这个需要用 R 或者 Python 来做的话，极短时间就可以完成。但如果一定要用 grep 来实现，一种可行的加速方法就是<strong>把可拆的元素最大程度拆分</strong>，极端的说，就是把 1 个 1 万行的文本拆成 1 万次分析，只运行 1 次。</p>
<p>当然，这些操作都是在你自己一台机器上利用自身多 CPU 特性完成的，如果你能同时操控 1 万台（即使性能很 low 的）机器，那就可以通过 remote 的方式来批量运行，这时「split-apply-combine」的分组思想就近似变成了「MapReduce」的并行思想，而在 linux 也有不少方法可以实现类似这样的效果。</p>
<p>本文所提到的在 linux 中并行主要针对两种需求：一种是只能单线程工作的命令比如 grep 和 sed 以及 bzip2 这类；另一种是一些虽然支持多线程但是并不能充分利用分配线程数的软件，比如 trimmomatic 在实际使用的时候给它 5 个或者 10 个甚至 20 个线程，但每次用到的就是两三个。</p>
<p>并行的使用场景也有两种：多文件和大文件。通常又可以把大文件的场景转换为多文件的场景去解决。</p>
<!--more-->
<p>首先介绍下文会用到的测试文件：</p>
<ul>
<li>37923 行的测试文件 file.txt（其实是 gff 格式）</li>
<li>5000 行的待查找文件 need.id （其实是转录本 id）</li>
</ul>
<p>为了模拟多文件处理场景，我们把 file.txt 分割成 100 个小文件，每个文件都是以 <code>split_file</code> 开头。</p>
<pre><code class="language-sh">split -n l/100 file.txt -d -a 3 split_file
# -n l/100 这个参数的写法略讲究，目的是为了防止 split 把某一行给拆开在两个文件。
</code></pre>
<p>最耗时做法：大文件直接 grep 的常规操作，在我当时的测试环境下需要 5 分多钟才能完成。</p>
<pre><code class="language-sh">time grep -w -f need.id file.txt &gt; filter.out

real	5m15.913s
user	5m15.772s
sys	0m0.140s

</code></pre>
<h2 id="shell-脚本">shell 脚本</h2>
<h3 id="多文件处理">多文件处理</h3>
<p>说到 linux 批量运行命令，可能最简单的就是在命令结尾使用 <code>&amp;</code> 从而让命令在后台执行紧接着再运行下一条命令。比如：</p>
<pre><code class="language-sh">for i in `ls split_file*`
do
grep -w -f need.id $i &gt; ${i}.out &amp;
done
</code></pre>
<p>这种命令处理方法要比直接对 100 个文件因此操作的总时长节省很多。但是也有一个问题，循环一旦结束 grep 的进程仍在后台执行，如果想让所有命令都结束之后这个脚本在结束，可以上一点技巧。</p>
<pre><code class="language-sh">for i in `ls split_file*`
do
    grep -w -f need.id $i &gt; ${i}.out &amp;
    pid+=(&quot;$!&quot;)
done
wait ${pid[@]}
</code></pre>
<p>在这里，使用 <code>$!</code> 来获得进程的 PID，<code>$!</code> 保存着最近一个后台进程的 PID，然后放入数组，用 wait 命令等待这些进程结束。但是这种方法一旦面临文件<strong>远远超过</strong>自己的线程数时容易失控，造成服务器卡顿甚至卡死。比较理想的改进是能够识别这个循环执行次数，当达到某个数量时就停止添加新任务等待前述命令结束。</p>
<p>如下所示，一旦循环执行次数超过了 19，就让循环等一等。</p>
<pre><code class="language-sh">t=0
for i in `ls split_file*`
do
    echo $i
    grep -w -f need.id $i &gt; ${i}.out &amp;
    sleep 1s
    t=$(($t+1))
    if [[ $t -gt 19 ]]
    then
        echo $t wait a moment
        wait
        t=0
    fi
done
</code></pre>
<h3 id="大文件处理">大文件处理</h3>
<p>大文件处理的思路其实和多文件很类似，只是需要我们提前把多文件拆分为大文件，例如我们把一个大文件利用 <code>split</code> 拆分为 100 个小文件，每次利用 20 个 cpu 同时运行，最后再把结果进行合并。这样会比直接操作一个大文件节省非常多的时间。</p>
<pre><code class="language-sh">t=0
for i in `ls split_file*`
do
    echo $i
    grep -w -f need.id $i &gt; ${i}.out &amp;
    t=$(($t+1))
    if [[ $t -gt 19 ]]
    then
        echo $t
        wait
        t=0
    fi
done
wait
cat split_file*out &gt; final.all.out &amp;&amp; rm -f split_file*out

# 脚本运行时间
#real	0m29.666s
#user	7m41.872s
#sys	0m3.312s
</code></pre>
<h2 id="ppss">PPSS</h2>
<p>当然，上面的脚本是我们的入门操作，如果仔细推敲存在不少问题而且不够灵活，例如不能时时刻刻充分利用好设定的最大线程数（上述为 20）。很早之前就有人写过一个更加复杂的 shell 脚本 <a href="https://github.com/louwrentius/PPSS">PASS</a> 来实现并行操作，这个脚本一共有 3000 多行，具体用法可以查看其 GitHub 的说明。</p>
<p>以下是一个明令行的帮助说明：</p>
<pre><code class="language-sh">ppss
|P|P|S|S| Distributed Parallel Processing Shell Script 2.60

usage: ./ppss [ -d &lt;sourcedir&gt; | -f &lt;sourcefile&gt; ]  [ -c '&lt;command&gt;&quot;$ITEM&quot;' ]
                 [ -C &lt;configfile&gt; ] [ -j ] [ -l &lt;logfile&gt; ] [ -p &lt;# jobs&gt; ]
                 [ -D &lt;delay&gt; ] [ -h ] [ --help ] [ -r ]

Examples:
                 ./ppss -d /dir/with/some/files -c 'gzip'
                 ./ppss -d /dir/with/some/files -c 'cp&quot;$ITEM&quot;/tmp' -p 2
                 ./ppss -f &lt;file&gt; -c 'wget -q -P /destination/directory&quot;$ITEM&quot;' -p 10
</code></pre>
<p>除了利用 bash 脚本，已经有大量写好的工具来完成这个需求，在这篇文章里简要介绍几个用的相对多的工具。</p>
<h2 id="parallel">parallel</h2>
<p>GNU parallel 这个命令在一部分服务器中可能没有被预装，通过 <a href="https://www.gnu.org/software/parallel/">官网</a> 进行下载安装。它应该是目前使用量最广的 linux 端并行工具，后续大多数工具都是在其思路上利用不同的语言进行开发，并且都是以它作为标准进行比较。</p>
<p>GNU parallel 的主要目的就是用来代替 xargs (<code>xargs -P</code> 可以实现并行处理) 和 for 循环这些操作，所以大多数用 for 来写的循环都可以使用 GNU parallel 来进行改写提速（解决多文件问题），同时它也可以把输入的大文件进行 block 切分再并行的进行处理（解决大文件问题）。</p>
<p>parallel 可以支持各种格式的输入，比如 stdin、单一文件、多个文件，命令行等等。可以输出 stdout，整合结果或者未整合结果。</p>
<h3 id="多文件处理-2">多文件处理</h3>
<pre><code class="language-sh"># 多文件压缩
ls split_file* |parallel gzip

# 多文件解压缩
ls split_file* |parallel gunzip
</code></pre>
<p>再比如一次创建 20 个目录</p>
<pre><code class="language-sh">seq 20 | parallel mkdir temp_{}
</code></pre>
<h3 id="大文件处理-2">大文件处理</h3>
<pre><code class="language-sh">time cat file.txt |parallel --pipe grep -w -f need.id &gt; temp.txt

real	2m0.893s
user	5m31.536s
sys	0m0.344s
</code></pre>
<p>时间从原始的 5 分多降低到 2 分钟，如果感觉上面的数据处理还不够快那么不要用默认参数可以有另一种写法，20s 搞定。</p>
<pre><code class="language-sh">time parallel --pipepart -a file.txt --block -10 grep -w -f need.id &gt; temp2.txt

real	0m21.260s
user	9m32.360s
sys	0m12.236s

</code></pre>
<h2 id="xjobs">xjobs</h2>
<p><a href="http://www.maier-komor.de/xjobs.html">xjobs</a> 也是一个平时会偶尔使用的命令，它可以直接执行命令行中的命令，也可以执行一个包含多个命令行的文件。然后自己根据分配的线程数进行分配，每一个命令结束就会启动新的命令，保证 CPU 的利用效率。</p>
<h3 id="多文件处理-3">多文件处理</h3>
<pre><code class="language-sh">
# 多文件压缩
ls split_file* |xjobs -j 20 gzip
# -j 指定处理线程数

# 多文件解压缩
ls split_file* |xjobs -j 20 gunzip
</code></pre>
<h3 id="大文件处理-3">大文件处理</h3>
<p>xjobs 如果需要进行大文件处理，需要首先对文件自行拆分，这里直接使用 split 好的文件。</p>
<pre><code class="language-sh">time ls split_file0* |xjobs -j20 -v0 grep -w -f need.id |grep -v bin &gt; temp4.txt

real	0m20.344s
user	6m5.264s
sys	0m2.748s

# xjobs 直接使用 sdtout 的时候有一个问题就是会写出执行的命令，需要在输出的结果中把命令行除去。

</code></pre>
<h2 id="rush">rush</h2>
<p><a href="https://github.com/shenwei356/rush">rush</a> 是 seqkit 开发者（江湖人称爪哥）的作品。因为爪哥本身做生物信息，在介绍这个工具时他还提到了在生物信息中的应用示例。而这个工具也体现出了爪哥一贯的风格，说明文档的用法示例清晰移动，给出各了种参数对应 GNU parallel 的功能，安排的明明白白。</p>
<h3 id="多文件处理-4">多文件处理</h3>
<p>多文件处理最基础的版本和其它工具类似，不过其借鉴了 awk 的赋值方法，可以利用 <code>-v</code> 给变量进行赋值。<strong>另外，如果命令被中断还可以通过 <code>-c</code> 继续进行。</strong></p>
<pre><code class="language-sh">ls split_file* |rush -j 20 'gunzip' -c
</code></pre>
<h3 id="大文件处理-4">大文件处理</h3>
<blockquote>
<p>rush 不支持直接传 stdin。你对一个文件 grep 操作，没法通过 rush 来并行。如果文件多的话，可以 <code>ls *.txt | rush 'cat {} | grep'</code> 这样多文件并行。<br>
--- 爪哥本爪</p>
</blockquote>
<p>我的理解：如果需要进行大文件的处理，可以自行对文件进行拆分，和 <code>xjobs</code> 类似，问题就再一次转换为多文件处理。</p>
<pre><code class="language-sh">time ls split_file0* |rush -j 20 'cat {} |grep -w -f need.id || true' &gt; temp5.txt
# 在 rush 中，直接使用 grep 会有问题，需要按照 grep foo bar || true 这样的格式来使用
real	0m18.891s
user	5m48.664s
sys	0m2.684s
</code></pre>
<h3 id="生物信息应用">生物信息应用</h3>
<p>因为爪哥特意给了一个 bwa 比对的例子，在这里直接引用一下，供参考。</p>
<pre><code class="language-sh">
A bioinformatics example: mapping with bwa, and processing result with samtools:

 $ tree raw.cluster.clean.mapping
 raw.cluster.clean.mapping
 ├── M1
 │   ├── M1_1.fq.gz -&gt; ../../raw.cluster.clean/M1/M1_1.fq.gz
 │   ├── M1_2.fq.gz -&gt; ../../raw.cluster.clean/M1/M1_2.fq.gz
 ...

 $ ref=ref/xxx.fa
 $ threads=25
 $ ls -d raw.cluster.clean.mapping/* \
     | rush -v ref=$ref -v j=$threads \
         'bwa mem -t {j} -M -a {ref} {}/{%}_1.fq.gz {}/{%}_2.fq.gz &gt; {}/{%}.sam; \
         samtools view -bS {}/{%}.sam &gt; {}/{%}.bam; \
         samtools sort -T {}/{%}.tmp -@ {j} {}/{%}.bam -o {}/{%}.sorted.bam; \
         samtools index {}/{%}.sorted.bam; \
         samtools flagstat {}/{%}.sorted.bam &gt; {}/{%}.sorted.bam.flagstat; \
         /bin/rm {}/{%}.bam {}/{%}.sam;' \
         -j 2 --verbose -c -C mapping.rush
Since {}/{%} appears many times, we can use preset variable (macro) to simplify it:

 $ ls -d raw.cluster.clean.mapping/* \
     | rush -v ref=$ref -v j=$threads -v p='{}/{%}' \
         'bwa mem -t {j} -M -a {ref} {p}_1.fq.gz {p}_2.fq.gz &gt; {p}.sam; \
         samtools view -bS {p}.sam &gt; {p}.bam; \
         samtools sort -T {p}.tmp -@ {j} {p}.bam -o {p}.sorted.bam; \
         samtools index {p}.sorted.bam; \
         samtools flagstat {p}.sorted.bam &gt; {p}.sorted.bam.flagstat; \
         /bin/rm {p}.bam {p}.sam;' \
         -j 2 --verbose -c -C mapping.rush
</code></pre>
<h2 id="其它">其它</h2>
<p>在 GNU parallel 的主页有一个详细的其它并行工具和 GNU parallel 的 <a href="https://www.gnu.org/software/parallel/parallel_alternatives.html">比较说明</a>，如果闲来没事可以仔细研究，如果想进一步学习，可以参考 GNU parallel 的 <a href="https://www.gnu.org/software/parallel/">详细官方说明</a>。</p>
<p>如果要推荐一种方法，十几万行的数据挑出几万行的内容，在 R 里 <code>merge</code> 一下或者 <code>left_join</code> 一下，基本没有感觉。</p>
<hr>
<h2 id="one-more-thing">one more thing</h2>
<p>以为文章到这里就结束了么，其实还没有……</p>
<p>如果你也感觉 grep 单线程处理这样大规模的数据集太慢了，那可能是还不太会用 grep。比如同样的需求，多加一个参数就可以让其无感完成，比上述所有方法都快出几个数量级。</p>
<pre><code class="language-sh">time grep -F -w -f need.id file.txt &gt; filter2.out

real	0m0.026s
user	0m0.016s
sys	0m0.008s
</code></pre>
<hr>
<figure data-type="image" tabindex="1"><img src="https://i.creativecommons.org/l/by-nc-nd/4.0/88x31.png" alt="" loading="lazy"></figure>
<p><strong>本文作者</strong>：思考问题的熊</p>
<p><strong>版权声明</strong>：本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-nd/4.0">知识共享署名 - 非商业性使用 - 禁止演绎 4.0 国际许可协议 (CC BY-NC-ND 4.0)</a> 进行许可。</p>
<figure data-type="image" tabindex="2"><img src="https://kaopubear-1254299507.cos.ap-shanghai.myqcloud.com/picgo/20190628083754.png" alt="扫码即刻沟通" loading="lazy"></figure>

        </div>
        <!-- Share to Twitter, Weibo, Telegram -->
        <div class="flex items-center">
          <div class="mr-4 flex items-center">
            <i class="ri-share-forward-line text-gray-500"></i>
          </div>
          <div class="px-4 cursor-pointer text-blue-500 hover:bg-blue-100 dark:hover:bg-gray-600 inline-flex" @click="shareToTwitter">
            <i class="ri-twitter-line"></i>
          </div>
          <div class="px-4 cursor-pointer text-red-500 hover:bg-red-100 dark:hover:bg-gray-600 inline-flex" @click="shareToWeibo">
            <i class="ri-weibo-line"></i>
          </div>
          <div class="px-4 cursor-pointer text-indigo-500 hover:bg-indigo-100 dark:hover:bg-gray-600 inline-flex" @click="shareToTelegram">
            <i class="ri-telegram-line"></i>
          </div>
        </div>
      </div>

      

      
        <div id="vlaine-comment"></div>
<script type="application/javascript" src="https://unpkg.com/valine"></script>
<script type="application/javascript">
  new Valine({
    el: '#vlaine-comment',
    appId: 'HJ4ltM8KvCxAwTaMUjzls2a1-gzGzoHsz',
    appKey: 'mk4aFvoMPRnkE0VRiuYBp1mc',
    pageSize: 10,
    notify: true,
    avatar: 'mp',
    verify: true,
    placeholder: '不妨评论交流',
    visitor: true,
    highlight: true,
    recordIP: true,
  })
</script>
      

      <footer class="py-12 text-center px-4 md:px-0" v-pre>
  欢迎加入我的 <a href="https://t.zsxq.com/UjiEaYZ" target="_blank">知识星球</a>
</footer>
    </div>

    <!-- TOC Container -->
    <div class="fixed right-0 bottom-0 mb-16 mr-4 shadow w-8 h-8 rounded-full flex justify-center items-center z-10 cursor-pointer bg-white dark:bg-gray-500 dark:text-gray-200 hover:shadow-lg transition-all animated fadeInRight" @click="showToc = true">
      <i class="ri-file-list-line"></i>
    </div>

    <div class="fixed right-0 top-0 bottom-0 overflow-y-auto w-64 bg-white dark:bg-gray-800 p-4 border-l border-gray-100 dark:border-gray-600 z-10 transition-fast" :class="{ '-mr-64': !showToc }">
      <div class="flex mb-4 justify-end">
        <div class="w-8 h-8 inline-flex justify-center items-center rounded-full cursor-pointer hover:bg-gray-200 dark:hover:bg-gray-600 transition-fast" @click="showToc = false">
          <i class="ri-close-line text-lg"></i>
        </div>
      </div>
      <div class="post-toc-container">
        <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#shell-%E8%84%9A%E6%9C%AC">shell 脚本</a>
<ul>
<li><a href="#%E5%A4%9A%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86">多文件处理</a></li>
<li><a href="#%E5%A4%A7%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86">大文件处理</a></li>
</ul>
</li>
<li><a href="#ppss">PPSS</a></li>
<li><a href="#parallel">parallel</a>
<ul>
<li><a href="#%E5%A4%9A%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86-2">多文件处理</a></li>
<li><a href="#%E5%A4%A7%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86-2">大文件处理</a></li>
</ul>
</li>
<li><a href="#xjobs">xjobs</a>
<ul>
<li><a href="#%E5%A4%9A%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86-3">多文件处理</a></li>
<li><a href="#%E5%A4%A7%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86-3">大文件处理</a></li>
</ul>
</li>
<li><a href="#rush">rush</a>
<ul>
<li><a href="#%E5%A4%9A%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86-4">多文件处理</a></li>
<li><a href="#%E5%A4%A7%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86-4">大文件处理</a></li>
<li><a href="#%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%BA%94%E7%94%A8">生物信息应用</a></li>
</ul>
</li>
<li><a href="#%E5%85%B6%E5%AE%83">其它</a></li>
<li><a href="#one-more-thing">one more thing</a></li>
</ul>
</li>
</ul>

      </div>
    </div>

    <!-- Back to top -->
    <div class="fixed right-0 bottom-0 mb-4 mr-4 shadow w-8 h-8 rounded-full flex justify-center items-center z-10 cursor-pointer bg-white hover:shadow-lg transition-all dark:bg-gray-500 dark:text-gray-200" @click="backToUp" v-show="scrolled">
      <i class="ri-arrow-up-line"></i>
    </div>
  </div>

  <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
  <!-- Background of PhotoSwipe. 
        It's a separate element as animating opacity is faster than rgba(). -->
  <div class="pswp__bg">
  </div>
  <!-- Slides wrapper with overflow:hidden. -->
  <div class="pswp__scroll-wrap">
    <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
    <div class="pswp__container">
      <div class="pswp__item">
      </div>
      <div class="pswp__item">
      </div>
      <div class="pswp__item">
      </div>
    </div>
    <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
    <div class="pswp__ui pswp__ui--hidden">
      <div class="pswp__top-bar">
        <!--  Controls are self-explanatory. Order can be changed. -->
        <div class="pswp__counter">
        </div>
        <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
        <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
        <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
        <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
        <!-- element will get class pswp__preloader--active when preloader is running -->
        <div class="pswp__preloader">
          <div class="pswp__preloader__icn">
            <div class="pswp__preloader__cut">
              <div class="pswp__preloader__donut">
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
        <div class="pswp__share-tooltip">
        </div>
      </div>
      <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
      </button>
      <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
      </button>
      <div class="pswp__caption">
        <div class="pswp__caption__center">
        </div>
      </div>
    </div>
  </div>
</div>

  <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
  <script src="https://kaopubear.top//media/scripts/main.js"></script>
  
  <!-- Code Highlight -->
  
    <script src="https://kaopubear.top//media/prism.js"></script>
    <script>
      Prism.highlightAll()
    </script>
  

  <script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>
  <script>
    //拿到预览框架，也就是上面的html代码
    var pswpElement = document.querySelectorAll('.pswp')[0];
    //定义图片数组变量
    var imgitems;
    /**
    * 用于显示预览界面
    * @param index 图片数组下标
    */
    function viewImg(index) {
      //其它选项这里不做过多阐述，详情见官网
      var pswpoptions = {
        index: parseInt(index, 10), // 开始幻灯片索引。0是第一张幻灯片。必须是整数，而不是字符串。
        bgOpacity: 0.7, // 背景透明度，0-1
        maxSpreadZoom: 3, // 缩放级别，不要太大
      };
      //初始化并打开PhotoSwipe，pswpElement对应上面预览框架，PhotoSwipeUI_Default为皮肤，imgitems为图片数组，pswpoptions为选项
      var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, imgitems, pswpoptions);
      gallery.init()
    }
    /**
    * 用于添加图片点击事件
    * @param img 图片元素
    * @param index 所属下标（在imgitems中的位置）
    */
    function addImgClick(img, index) {
      img.onclick = function() {
        viewImg(index)
      }
    }
    /**
    * 轮询所有图片，获取src、width、height等数据，加入imgitems，并给图片元素添加事件
    * 最好在onload中执行该方法，本站因放在最底部，所以直接初始化
    * 异步加载图片可在图片元素创建完成后调用此方法
    */
    function initImg() {
      //重置图片数组
      imgitems = [];
      //查找class:markdown 下的所有img元素并遍历
      var imgs = document.querySelectorAll('.markdown img');
      for (var i = 0; i < imgs.length; i++) {
        var img = imgs[i];
        //本站相册初始为loading图片，真实图片放在data-src
        var ds = img.getAttribute("data-src");
        //创建image对象，用于获取图片宽高
        var imgtemp = new Image();
        //判断是否存在data-src
        if (ds != null && ds.length > 0) {
          imgtemp.src = ds
        } else {
          imgtemp.src = img.src
        }
        //判断是否存在缓存
        if (imgtemp.complete) {
          var imgobj = {
            "src": imgtemp.src,
            "w": imgtemp.width,
            "h": imgtemp.height,
          };
          imgitems[i] = imgobj;
          addImgClick(img, i);
        } else {
          console.log('进来了2')
          imgtemp.index = i;
          imgtemp.img = img;
          imgtemp.onload = function() {
            var imgobj = {
              "src": this.src,
              "w": this.width,
              "h": this.height,
            };
            //不要使用push，因为onload前后顺序会不同
            imgitems[this.index] = imgobj
            //添加点击事件
            addImgClick(this.img, this.index);
          }
        }
      }
    }
    //初始化
    initImg();
  </script>
</body>

</html>